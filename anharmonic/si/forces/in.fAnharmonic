# ----------- Basic setup ----
atom_style      atomic
units           metal
dimension       3
boundary        p p p
processors      * * *

atom_modify	map hash
read_data       data.forces

#----------- Define potential and useful quantities ----
pair_style      tersoff
pair_coeff      * * SiCGe.tersoff Si(D) Ge

timestep        0.0005				##In picoseconds
thermo          1000

variable 	Vac equal 40.00
variable	NX equal lx-${Vac}
print		${NX}

#---------------- Define the interface -----------------
variable 	xmid equal 41.9343
variable	dmid equal 3

variable 	xmidL equal ${xmid}-0.075 	##Small buffer to avoid double counting
variable	xmidR equal ${xmid}+0.075
variable 	xmidlo equal ${xmidL}-${dmid}
variable 	xmidhi equal ${xmidR}+${dmid}

region 		left block ${xmidlo} ${xmidL} INF INF INF INF  units box
region 		right block ${xmidR} ${xmidhi} INF INF INF INF  units box
group 		interface_left region left
group 		interface_right region right
group 		interface union interface_left interface_right

print 		'The interface is at ${xmidlo}, ${xmid}, ${xmidhi}'

#------------------Compute Forces on atoms--------------------------------------
compute 	fxfyfz interface_right property/atom fx fy fz

compute 	fxs interface_right property/atom fx
compute 	fys interface_right property/atom fy
compute 	fzs interface_right property/atom fz

#-------------------------- run 0 ------------------------------------------------
fix 		NVE all nve #update trajectories

variable 	N equal "count(all)"
variable	NL equal "count(interface_left)"
variable 	NR equal "count(interface_right)"
variable	Ninter equal ${NL}+${NR}

#----------------------------Initialize groups--------------------------------------
group 		thisi id 1

variable 	du equal 0.01 # Amount of displacement
variable 	du2 equal -2*${du}

variable	fname string "Fijk.dat"
shell 		rm Fijk.dat

dump 		forces interface_right custom 1 ${fname} id c_fxs c_fys c_fzs
dump_modify 	forces sort id
dump_modify 	forces append yes

#---------------- WRITE THE INTERFACE PARTICLES IDs and TYPEs TO Fijk.dat---------
print 		"NL ${NL}" append ${fname} #number of atoms in left group
print 		"NR ${NR}" append ${fname} #number of atoms in right group

label 		loop1
variable 	i1 loop $N #loop over all atoms
	variable 	xi equal x[${i1}] 	#loop over all atoms
	variable 	boolleft equal (${xi}<=${xmidL})&&(${xi}>=${xmidlo}) #atom is in left group
	variable 	boolright equal (${xi}>=${xmidR})&&(${xi}<=${xmidhi}) #atom is in right group
	if 		"${boolleft}" then &
				"print '${i1} 1' append ${fname}"
	if 		"${boolright}" then &
				"print '${i1} 2' append ${fname}"
	next 		i1 	#update loop counter

jump 		SELF loop1 	#return to loop


#---------- Loop over each atom that is being displaced ------------------------------------------
# The force constants are d^2Fi/drjdrk, this loops over the j atoms. Within each loop, j is moved in +x, -x, +y, -y, +z, -z
# Each time j is moved, a similar loop is run over k and k is moved in +x, -x, +y, -y, +z, -z. Each time k is moved, the forces
# acting on i in x, y, and z are printed.

print 		"du ${du}" append ${fname}
thermo_modify 	flush yes


group		thisk id 1 		#just a place holder, ignore it
variable	counter2 equal 0

label 		loop_i
variable 	i loop $N #loop over all atoms again, discard ones not in left group
	variable 	xi equal x[${i}]
	variable 	boolleft equal (${xi}<=${xmidL})&&(${xi}>=${xmidlo})
	variable 	boolright equal (${xi}>=${xmidR})&&(${xi}<=${xmidhi})
	print 		'$i ${boolleft} ${boolright}'
	if 		"!${boolleft}" then &
			"next i" &
			"jump SELF loop_i" &
			"jump SELF final_break" #Skip the iteration if atom not in left side

	group 		thisi delete
	group 		thisi id $i
	print 		"Atom j=${i}"

####################################################################################################
#
#
#####################################################################################################
	#---------------- X DIRECTION DISPLACEMENTS TO POSITIVE AND NEGATIVE DIRECTION-------------------
	displace_atoms 		thisi move ${du} 0 0 		#move j plus x
	####################################################################################################
	#---------- LOOP OVER ATOMS K AND DISPLACE IN X, Y, Z ------------------------------------------
	label		loopk1
	variable 	k loop ${N} 			#loop over all interface atoms
		variable 	xk equal x[${k}]
		variable 	boolinter equal (${xk}<=${xmidhi})&&(${xk}>=${xmidlo})
		# print 		'$k ${boolinter}'
		if 		"!${boolinter}" then &
				"next k" &
				"jump SELF loopk1" &
				"jump SELF break1" #Skip the iteration if atom not in interface

		print 		"Atom k=${k}"
		group		thisk delete
		group		thisk id $k

		#---------------- X DIRECTION DISPLACEMENTS TO POSITIVE AND NEGATIVE DIRECTION------------------
		displace_atoms 		thisk move ${du} 0 0 		#move k plus x
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move ${du2} 0 0		#move k minus x
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move ${du} 0 0		#move k to equilibrium pos

		#---------------- Y DIRECTION DISPLACEMENTS TO POSITIVE AND NEGATIVE DIRECTION--------------------
		displace_atoms 		thisk move 0 ${du} 0		#move k plus y
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move 0 ${du2} 0		#move k minus y
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move 0 ${du} 0		#move k to equilibrium pos

		#--------------- Z DIRECTION DISPLACEMENTS TO POSITIVE AND NEGATIVE DIRECTION---------------------
		displace_atoms 		thisk move 0 0 ${du}		#move k plus z
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move 0 0 ${du2}		#move k minus z
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move 0 0 ${du}		#move k to equilibrium pos

	next		k
	jump 		SELF loopk1
	label   break1
	##################################################################################################

	displace_atoms 		thisi move ${du2} 0 0 		#move j minus x
	####################################################################################################
	#---------- LOOP OVER ATOMS K AND DISPLACE IN X, Y, Z ------------------------------------------
	label		loopk2
	variable 	k loop ${N}			#loop over all interface atoms
		variable 	xk equal x[${k}]
		variable 	boolinter equal (${xk}<=${xmidhi})&&(${xk}>=${xmidlo})
		# print 		'$k ${boolinter}'
		if 		"!${boolinter}" then &
				"next k" &
				"jump SELF loopk2" &
				"jump SELF break2" #Skip the iteration if atom not in interface

		print 		"Atom k=${k}"
		group		thisk delete
		group		thisk id $k

		#---------------- X DIRECTION DISPLACEMENTS TO POSITIVE AND NEGATIVE DIRECTION-------------------
		displace_atoms 		thisk move ${du} 0 0 		#move k plus x
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move ${du2} 0 0		#move k minus x
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move ${du} 0 0		#move k to equilibrium pos

		#---------------- Y DIRECTION DISPLACEMENTS TO POSITIVE AND NEGATIVE DIRECTION--------------------
		displace_atoms 		thisk move 0 ${du} 0		#move k plus y
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move 0 ${du2} 0		#move k minus y
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move 0 ${du} 0		#move k to equilibrium pos

		#--------------- Z DIRECTION DISPLACEMENTS TO POSITIVE AND NEGATIVE DIRECTION----------------------
		displace_atoms 		thisk move 0 0 ${du}		#move k plus z
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move 0 0 ${du2}		#move k minus z
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move 0 0 ${du}		#move k to equilibrium pos

	next		k
	jump 		SELF loopk2
	label		break2
	##################################

	displace_atoms 		thisi move ${du} 0 0		#move j to equilibrium pos
####################################################################################################
#
#
#####################################################################################################
	#---------------- Y DIRECTION DISPLACEMENTS TO POSITIVE AND NEGATIVE DIRECTION---------------------

	displace_atoms 		thisi move 0 ${du} 0		#move j plus y
	####################################################################################################
	#---------- LOOP OVER ATOMS K AND DISPLACE IN X, Y, Z ------------------------------------------
	label		loopk3
	variable 	k loop ${N}				#loop over all interface atoms
		variable 	xk equal x[${k}]
		variable 	boolinter equal (${xk}<=${xmidhi})&&(${xk}>=${xmidlo})
		# print 		'$k ${boolinter}'
		if 		"!${boolinter}" then &
				"next k" &
				"jump SELF loopk3" &
				"jump SELF break3" #Skip the iteration if atom not in interface

		print 		"Atom k=${k}"
		group		thisk delete
		group		thisk id $k

		#---------------- X DIRECTION DISPLACEMENTS TO POSITIVE AND NEGATIVE DIRECTION------------------
		displace_atoms 		thisk move ${du} 0 0 		#move k plus x
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move ${du2} 0 0		#move k minus x
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move ${du} 0 0		#move k to equilibrium pos

		#---------------- Y DIRECTION DISPLACEMENTS TO POSITIVE AND NEGATIVE DIRECTION--------------------
		displace_atoms 		thisk move 0 ${du} 0		#move k plus y
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move 0 ${du2} 0		#move k minus y
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move 0 ${du} 0		#move k to equilibrium pos

		#--------------- Z DIRECTION DISPLACEMENTS TO POSITIVE AND NEGATIVE DIRECTION---------------------
		displace_atoms 		thisk move 0 0 ${du}		#move k plus z
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move 0 0 ${du2}		#move k minus z
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move 0 0 ${du}		#move k to equilibrium pos

	next		k
	jump 		SELF loopk3
	label		break3
	##################################################################################################

	displace_atoms 		thisi move 0 ${du2} 0		#move j minus y
	####################################################################################################
	#---------- LOOP OVER ATOMS K AND DISPLACE IN X, Y, Z ------------------------------------------
	label		loopk4
	variable 	k loop ${N}					#loop over all interface atoms
		variable 	xk equal x[${k}]
		variable 	boolinter equal (${xk}<=${xmidhi})&&(${xk}>=${xmidlo})
		# print 		'$k ${boolinter}'
		if 		"!${boolinter}" then &
				"next k" &
				"jump SELF loopk4" &
				"jump SELF break4" #Skip the iteration if atom not in interface

		print 		"Atom k=${k}"
		group		thisk delete
		group		thisk id $k

		#---------------- X DIRECTION DISPLACEMENTS TO POSITIVE AND NEGATIVE DIRECTION------------------
		displace_atoms 		thisk move ${du} 0 0 		#move k plus x
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move ${du2} 0 0		#move k minus x
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move ${du} 0 0		#move k to equilibrium pos

		#---------------- Y DIRECTION DISPLACEMENTS TO POSITIVE AND NEGATIVE DIRECTION--------------------
		displace_atoms 		thisk move 0 ${du} 0		#move k plus y
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move 0 ${du2} 0		#move k minus y
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move 0 ${du} 0		#move k to equilibrium pos

		#--------------- Z DIRECTION DISPLACEMENTS TO POSITIVE AND NEGATIVE DIRECTION---------------------
		displace_atoms 		thisk move 0 0 ${du}		#move k plus z
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move 0 0 ${du2}		#move k minus z
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move 0 0 ${du}		#move k to equilibrium pos

	next		k
	jump 		SELF loopk4
	label		break4
	##################################################################################################

	displace_atoms 		thisi move 0 ${du} 0		#move j to equilibrium pos
####################################################################################################
#
#
#####################################################################################################
	#--------------- Z DIRECTION DISPLACEMENTS TO POSITIVE AND NEGATIVE DIRECTION----------------------
	displace_atoms 		thisi move 0 0 ${du}		#move j plus z
	####################################################################################################
	#---------- LOOP OVER ATOMS K AND DISPLACE IN X, Y, Z ------------------------------------------
	label		loopk5
	variable 	k loop ${N}					#loop over all interface atoms
		variable 	xk equal x[${k}]
		variable 	boolinter equal (${xk}<=${xmidhi})&&(${xk}>=${xmidlo})
		# print 		'$k ${boolinter}'
		if 		"!${boolinter}" then &
				"next k" &
				"jump SELF loopk5" &
				"jump SELF break5" #Skip the iteration if atom not in interface

		print 		"Atom k=${k}"
		group		thisk delete
		group		thisk id $k

		#---------------- X DIRECTION DISPLACEMENTS TO POSITIVE AND NEGATIVE DIRECTION------------------
		displace_atoms 		thisk move ${du} 0 0 		#move k plus x
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move ${du2} 0 0		#move k minus x
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move ${du} 0 0		#move k to equilibrium pos

		#---------------- Y DIRECTION DISPLACEMENTS TO POSITIVE AND NEGATIVE DIRECTION--------------------
		displace_atoms 		thisk move 0 ${du} 0		#move k plus y
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move 0 ${du2} 0		#move k minus y
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move 0 ${du} 0		#move k to equilibrium pos

		#--------------- Z DIRECTION DISPLACEMENTS TO POSITIVE AND NEGATIVE DIRECTION---------------------
		displace_atoms 		thisk move 0 0 ${du}		#move k plus z
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move 0 0 ${du2}		#move k minus z
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move 0 0 ${du}		#move k to equilibrium pos

	next		k
	jump 		SELF loopk5
	label		break5
	##################################################################################################

	displace_atoms 		thisi move 0 0 ${du2}  		#move j minus z
	####################################################################################################
	#---------- LOOP OVER ATOMS K AND DISPLACE IN X, Y, Z ------------------------------------------
	label		loopk6
	variable 	k loop ${N}						#loop over all interface atoms
		variable 	xk equal x[${k}]
		variable 	boolinter equal (${xk}<=${xmidhi})&&(${xk}>=${xmidlo})
		# print 		'$k ${boolinter}'
		if 		"!${boolinter}" then &
				"next k" &
				"jump SELF loopk6" &
				"jump SELF break6" #Skip the iteration if atom not in interface

		print 		"Atom k=${k}"
		group		thisk delete
		group		thisk id $k

		#---------------- X DIRECTION DISPLACEMENTS TO POSITIVE AND NEGATIVE DIRECTION------------------
		displace_atoms 		thisk move ${du} 0 0 		#move k plus x
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move ${du2} 0 0		#move k minus x
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move ${du} 0 0		#move k to equilibrium pos

		#---------------- Y DIRECTION DISPLACEMENTS TO POSITIVE AND NEGATIVE DIRECTION--------------------
		displace_atoms 		thisk move 0 ${du} 0		#move k plus y
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move 0 ${du2} 0		#move k minus y
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move 0 ${du} 0		#move k to equilibrium pos

		#--------------- Z DIRECTION DISPLACEMENTS TO POSITIVE AND NEGATIVE DIRECTION---------------------
		displace_atoms 		thisk move 0 0 ${du}		#move k plus z
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move 0 0 ${du2}		#move k minus z
		variable 		counter2 equal ${counter2}+1
		reset_timestep 		${counter2}
		run 			0 # Update the forces in the compute

		displace_atoms 		thisk move 0 0 ${du}		#move k to equilibrium pos

	next		k
	jump 		SELF loopk6
	label		break6
	##################################################################################################

	displace_atoms 		thisi move 0 0 ${du}		#move j to equilibrium pos
###################################################################################################
###################################################################################################
next 		i
jump 		SELF loop_i

label 		final_break
print 		"all done"
